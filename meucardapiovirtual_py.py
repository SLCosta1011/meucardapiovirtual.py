# -*- coding: utf-8 -*-
"""meucardapiovirtual-py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/SLCosta1011/12064aec31d2c3841399b2b4b7d1818b/meucardapiovirtual-py.ipynb

MEMBROS: Davi Rosa de Jesus
         Erick de Oliveira Soares
         Gabriel Silva Costa
         Gustavo Bruno Sales David
"""

!pip install -q PyMuPDF==1.24.10 PyPDF2 requests

# ===============================================================
# üìò ASSISTENTE DE CARD√ÅPIO - IA PDF (PIZZARIA)
# ===============================================================

# --- Upload do PDF ---
from google.colab import files
import os

uploaded = files.upload()  # Selecione seu arquivo .pdf (card√°pio)
if not uploaded:
    raise RuntimeError("Nenhum arquivo foi enviado. Execute novamente e selecione o PDF.")

pdf_filename = list(uploaded.keys())[0]
PDF_PATH = os.path.join("/content", pdf_filename)

print("‚úÖ PDF enviado com sucesso.")
print("üìÇ Caminho completo:", PDF_PATH)

# 2 Configura√ß√µes

OPENROUTER_API_KEY = ""

MODEL_NAME = "mistralai/mistral-7b-instruct"

CACHE_FILE = "cache_cardapio.pkl"

FORCE_REBUILD_CACHE = True

# Configura√ß√µes de Chunking (divis√£o do PDF em peda√ßos)
CHUNK_SIZE = 1800
CHUNK_OVERLAP = 250

# Limites do modelo
MAX_OUTPUT_TOKENS = 300
MAX_CONTEXT_CHARS = 9000

# ===============================================================
# üîß Fun√ß√µes utilit√°rias
# ===============================================================
import unicodedata
from typing import List, Tuple
import fitz # PyMuPDF
import PyPDF2


def _remove_accents(s: str) -> str:
    return "".join(c for c in unicodedata.normalize("NFKD", s) if not unicodedata.combining(c))

def _chunk_text(text: str, size: int, overlap: int) -> List[str]:
    chunks = []
    start = 0
    n = len(text)
    while start < n:
        end = min(start + size, n)
        chunks.append(text[start:end])
        if end == n:
            break
        start = end - overlap
        if start < 0:
            start = 0
    return chunks

def _read_pdf_with_pymupdf(path: str) -> str:
    doc = fitz.open(path)
    pages_txt = [pg.get_text("text") or "" for pg in doc]
    doc.close()
    return "\n".join(pages_txt)

def _read_pdf_with_pypdf2(path: str) -> str:
    with open(path, "rb") as f:
        reader = PyPDF2.PdfReader(f)
        return "\n".join(page.extract_text() or "" for page in reader.pages)

# ===============================================================
# üß† Processamento do PDF
# ===============================================================
import pickle
import os

def carregar_pdf_com_cache(pdf_path: str = PDF_PATH,
                           cache_file: str = CACHE_FILE,
                           chunk_size: int = CHUNK_SIZE,
                           chunk_overlap: int = CHUNK_OVERLAP) -> List[str]:
    """Extrai texto do PDF, divide em blocos e salva em cache."""
    if (not FORCE_REBUILD_CACHE) and os.path.exists(cache_file):
        with open(cache_file, "rb") as f:
            return pickle.load(f)

    try:
        full_text = _read_pdf_with_pymupdf(pdf_path)
    except Exception:
        full_text = _read_pdf_with_pypdf2(pdf_path)

    full_text = (full_text or "").replace("\r", " ").replace("\u00A0", " ").strip()
    chunks = _chunk_text(full_text, chunk_size, chunk_overlap)

    with open(cache_file, "wb") as f:
        pickle.dump(chunks, f)
    return chunks

def diagnostico_pdf(blocos: List[str], preview_chars: int = 400):
    print(f"üìÑ {len(blocos)} blocos carregados.")
    if blocos:
        print(f"üß© Primeiro bloco ({len(blocos[0])} chars):\n", blocos[0][:preview_chars])
    else:
        print("‚ö†Ô∏è Nenhum texto extra√≠do (pode ser PDF escaneado).")

# ===============================================================
# üîç Sele√ß√£o de blocos relevantes
# ===============================================================

def _score_chunk(query: str, chunk: str) -> int:
    q = _remove_accents(query.lower())
    c = _remove_accents(chunk.lower())
    q_terms = [t for t in q.split() if len(t) >= 3]
    return sum(c.count(t) for t in q_terms)

def selecionar_melhores_blocos(pergunta: str, blocos: List[str], k: int = 5) -> List[Tuple[int, str]]:
    scored = [(i, b, _score_chunk(pergunta, b)) for i, b in enumerate(blocos)]
    scored.sort(key=lambda x: x[2], reverse=True)
    top_raw = [(i, b, s) for i, b, s in scored[:k]]

    # print("\nüèÜ Blocos mais relevantes:")
    # for i, b, s in top_raw:
    #     print(f"  - #{i} | score={s} | {b[:100].replace('\n', ' ')}")

    top = [(i, b) for i, b, s in top_raw if s > 0]
    if not top and blocos:
        top = [(0, blocos[0])]
    return top

def montar_contexto(blocos_escolhidos: List[Tuple[int, str]], max_chars: int = MAX_CONTEXT_CHARS) -> str:
    contexto = []
    total = 0
    for idx, chunk in blocos_escolhidos:
        trecho = f"\n[Bloco #{idx}]\n{chunk.strip()}\n"
        if total + len(trecho) > max_chars:
            break
        contexto.append(trecho)
        total += len(trecho)
    return "".join(contexto).strip()

# ===============================================================
# ü§ñ Chamada ao modelo (OpenRouter)
# ===============================================================
import requests

def perguntar_openrouter(pergunta: str, contexto: str, model: str = MODEL_NAME) -> str:
    if not OPENROUTER_API_KEY or not OPENROUTER_API_KEY.startswith("sk-"):
        return "‚ö†Ô∏è API Key inv√°lida. Configure sua chave do OpenRouter."

    system_msg = (
        "Voc√™ √© um assistente de card√°pio. "
        "Responda com base nas informa√ß√µes do PDF (sabores, ingredientes e pre√ßos). "
        "Responda o pre√ßo do pedido, somando o valor da pizza com o valor da bebida, caso o usu√°rio pe√ßa as duas coisas. Se n√£o, responda sobre o pedido, inclusive se forem separados"
        "As formas de pagamento s√£o: pix, d√©bito e cart√£o de cr√©dito (com parcela a vista(em uma vez)). N√£o mencione isso at√© o usu√°rio perguntar"
        "APENAS ap√≥s o usu√°rio perguntar sobre o pagamento e digitar a forma de pagamento diga: Obrigado pela prefer√™ncia, tenha um bom apetite"
        "Se n√£o conseguir encontrar a informa√ß√£o, diga exatamente: 'Desculpe, n√£o tenho acesso a essa informa√ß√£o.'"
    )

    user_prompt = f"""
[CONTE√öDO DO CARD√ÅPIO]
{contexto}

[PERGUNTA]
{pergunta}

Responda com base no card√°pio.
""".strip()

    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
        "X-Title": "Card√°pio IA - Pizzaria",
    }

    body = {
        "model": model,
        "messages": [
            {"role": "system", "content": system_msg},
            {"role": "user", "content": user_prompt},
        ],
        "max_tokens": MAX_OUTPUT_TOKENS,
    }

    try:
        resp = requests.post("https://openrouter.ai/api/v1/chat/completions",
                             headers=headers, json=body, timeout=90)
        resp.raise_for_status()
        data = resp.json()
        return data["choices"][0]["message"]["content"].strip()
    except Exception as e:
        return f"‚ùå Erro: {e}"

def responder_pergunta(pergunta: str):
    """Processa a pergunta do usu√°rio, busca no PDF e responde usando o modelo."""
    print("ü§î S√≥ um momento...")
    blocos = carregar_pdf_com_cache()

    blocos_relevantes = selecionar_melhores_blocos(pergunta, blocos)
    if not blocos_relevantes:
        print("N√£o disponivel")
        return

    contexto = montar_contexto(blocos_relevantes)
    resposta = perguntar_openrouter(pergunta, contexto)

    print("\nü§ñ")
    print(resposta)

# Loop interativo para fazer perguntas
print("Bem Vindo ao seu cardapio inteligente!!. Digite 'sair' ou 'fim' para encerrar.")

print("Meu Card√°pio Vitual - MCV")
while True:
    pergunta_usuario = input("\nFa√ßa seu pedido: ")
    if pergunta_usuario.lower() in ['sair', 'fim']:
        print("Encerrando o assistente.")
        break
    if pergunta_usuario:
        responder_pergunta(pergunta_usuario)
